---
layout: page
title: Google Summer of Code 2018
---

## <span style="text-align:center;">*R project for geometrical statistics*
### <span style="text-align:center;">Volume approximation and sampling in high dimensions

You can read the proposal [here](https://drive.google.com/file/d/1CsblG42xXLoyYiDmcCSjRJhL3Eilxk5u/view)

#### *Abstract*

Volume computation of convex polytopes and sampling algorithms are very useful in many scientific fields
and applications. The VolEsti is a C++ software package for volume approximation and scales to a few
hundreds dimensions in contrast to currently available packages. Thus it could be an essential tool for
a quite large number of scientific applications that need fast volume approximation or sampling in high
dimensions. The goal of this project is to provide a friendly and efficient interface of VolEsti in a high
level language as R. Second to propose additions that might be useful for some scientific applications,
especially in economics and in biogeography and control, by extending VolEsti. Furthermore this new R package
would provide necessary tools for some other future extensions that could be used in applications in biology
and optimization problems. We hope this project will be a decisive contribution towards the first complete
and efficient tool for geometrical statistics and thus, help educational programs, research or even serve
as a building block towards an international, interdisciplinary community in geometrical statistics.

#### *Bonding period*

  
* ##### *1st week*  
Working together with my mentors on the algorithmic part of the project and especially on Volume computation for Zonotopes. Here are some important papers for our work: 
* Zonotopes and the LP-Newton method [here](https://link.springer.com/article/10.1007%2Fs11081-008-9067-x)
* Goffin's Algorithm for Zonotopes [here](https://dml.cz/bitstream/handle/10338.dmlcz/143088/Kybernetika_48-2012-5_5.pdf)
* Methods for order reduction of Zonotopes [here](https://ieeexplore.ieee.org/document/8264508/)

[Here](https://opencobra.github.io/cobratoolbox/stable/tutorials/tutorialUniformSampling.html) you can see an application (not included in the proposal) in biology that needs uniform sampling from zonotopes.
  
* ##### *2nd week*
Working on the main algorithm of the project: We study state-of-the-art volume computation algorithms, as Ben Cousin's and Santosh Vempala's [cooling gaussian](https://arxiv.org/abs/1409.6011) algorithm, and reschedule the deliverables in order to implement them as well. The main advantages are (a) better time efficiency, (b) less code and neccesary R and C++ packages and (c) more choices and flexibility for the user depending the problem.

The cooling gaussian algorithm takes some fundamental ideas from Lovasz's-Vemapla's [LV](http://web.cs.elte.hu/~lovasz/vol4-focs-tr.pdf) algorithm. A practical version of a combination of these two algorithms is given [here](http://mpc.zib.de/index.php/MPC/article/view/178/99) with very encouraging results. Comparing with VolEsti (or an improved version of VolEsti) is an important issue.

The final goal is an application with a variety of choices depending on the problem, the dimension, the sample distribution requested and the type of the convex body.

* ##### *3rd week*
Setting up the project environment at [github](https://github.com/TolisChal/volume_approximation/tree/develop). Everything is ready for the coding period!  
We made the following changes to the Deliverables - time schedule:  

* After we complete the Part I of the project we are going to implement Cousin's and Vempala's algorithm for the general convex body case.
* We have to write new classes for the ellipsoid.
* We are not going to need any SOCP solver.
* We have to modify the RCHR function in order to get a new point in each step and sample from the gaussian distribution.
* We are going to need a new function for the ScheduleAnnealing.

### *Coding Period*

Coding period has started. You can see our progress at [github](https://github.com/TolisChal/volume_approximation/tree/develop).  

* ##### *1st week*  

*CGAL exclusion completed.* We created a new Cartesian Kernel and a new Point class. We consider points and vectors, starting at the origin, to be the same. So we define the following operators: +, - , (double)*(point).

* ##### *2nd week* 
1) Boost exclusion completed.  
2) We implemented a new class for generating random points on a hypersphere, needed for the Random Direction Hit and Run.  
3) We have built a R interface using Rcpp. Now our C++ code is able to be excecuted through R.

In folder include we develop the pure C++ code of the project, using a C++ main function.  
In folder test we compile the C++ code with g++ compiler in order to test the algorithm when we make changes.  
In folder R-proj/src we develop the RCpp interface.  

4) We have added new classes for the ellipsoid, for the intersection of a polytope with an ellipsoid and for the intersection of a ball with a polytope and an ellipsoid.  

* ##### *3rd week* 
1) We have implemented rounding function, based on SVD decomposition given by [Vempala and Cousin](http://mpc.zib.de/index.php/MPC/article/view/178/99). We use RcppEigen library.  
2) We have defined a member function in class StdHPolytope (not ready for use) in order to apply linear transformation to an H-polytope. The input is of type Eigen::MatrixXd and the trasformation reduces to a matrix multiplication. We might replace class member stdMatrix with Eigen::MatrixXd in future in order to have a more simple code.  
3) We tested [cpplex](https://code.google.com/archive/p/cpplex/) combined with C++ pilal (Pathetically Inadequate Linear Algebra Library). An interface using cpplex and pilal is given [here](https://github.com/tunnuz/cpplex). We develop this project to a header only library (both cpplex and pilal) and wrote a C++ interface that takes a H-polytope as an input and computes the chebychev ball. We reject this solver because it is not enough time efficient for our needs.

* ##### *4th week*
1) We consider the Chebychev ball problem as an optimization problem for which optimization algorithms, such as [BfgsSolver](https://en.wikipedia.org/wiki/Broyden%E2%80%93Fletcher%E2%80%93Goldfarb%E2%80%93Shanno_algorithm), [LbfgsbSolver](https://en.wikipedia.org/wiki/Limited-memory_BFGS) or [SLSQP_Solver](http://degenerateconic.com/slsqp/) can be used. We used [CppOptimizationLibrary](https://github.com/PatWie/CppNumericalSolvers) by building a C++ interface for the chebychev ball computation, but these methods need a starting point in the interior of the polytope in order to converge. We note these methods because we will try to use them for the V-polytope membership later. We might use the [Dlib](http://dlib.net/) implementations using the [R interface](https://cran.r-project.org/web/packages/dlib/README.html).  
2) We are trying to [call](http://lpsolve.sourceforge.net/5.5/Build.htm) lpSolve library dynamically. An alternative is to use the [linear solver](https://github.com/google/or-tools/tree/master/ortools/linear_solver) from [Google's Operations Research tools](https://developers.google.com/optimization/).  
3) For the SOCP problem we are going to use [ECOSolver](https://cran.r-project.org/web/packages/ECOSolveR/index.html) as we know that is quite efficient for our application.

* ##### *first evaluation is open*
Comparing to the Deliverables in the [proposal](https://drive.google.com/file/d/1CsblG42xXLoyYiDmcCSjRJhL3Eilxk5u/view?usp=sharing):  
1) We completed all the parts except of the linear solver replacement because we did not expect it to be so difficult to find an efficient, C++ header only, open source solver, but we discover new intersting techniques that might be used in the next weeks for the V-polytope volume computation.  
2) We have completed all 5th week's work, by replacing the Boost library and completing the Rcpp interface.  
3) We have completed 6th week's work except V-polytope class by implementing the classes for the non-linear bodies of the Part II of the project.  
  
For the linear programming solver we worked on the following implementations:  
1) [cpplex](https://code.google.com/archive/p/cpplex/). We made changes to be a header-only library. We tested and rejected because it is inefficient for our project. It computed the Chebychev center of a 100-dimensional hypercube in 5.2 sec. when CGAL solver took 0.12sec.  
2) [CppOptimizationLibrary](https://github.com/PatWie/CppNumericalSolvers) and [Dlib](http://dlib.net/). An interior point is needed for this approach.  
3) [linear solver](https://github.com/google/or-tools/tree/master/ortools/linear_solver). This is our main alternative, but "linear_solver_test.cc" file is missing.  
4) [lpsolve](http://lpsolve.sourceforge.net/5.5/Build.htm). We are trying to implement a dynamic or a static call.  


* ##### *5th week*
1) Use lpSolve library using static linking with external library liblpsolve55.so (completed).  
2) lpSolve seems to be quite efficient for our application. We did run experiments but seems to be comparable with cgal's LP solver.  

* ##### *6th week*
1) We have completed Rcpp package "volesti". CGAL and BOOST exclusion is completed and C++ and R interfaces are ready for use and experiments.  
2) We are ready for the first pull request.  
3) We have started implementing Cousin's - Vempala'a algorithm.

* #### *TODO List* (Always at the bottom)  
1) Improve function for the linear transformation of a H-polytope.  
2) Test [R ClpAPI](https://cran.r-project.org/web/packages/clpAPI/vignettes/clpAPI.pdf). Build the C++ Clp implementation for the C++ test-interface and use R ClpAPI for the R interface of our project.  
3) Implement Khachiyan algorithm for the minimum enclosing (or covering) ellipsoid of a point set. That will be the main routine of a second function for rounding convex bodies.
